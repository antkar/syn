/*
 * Copyright 2013 Anton Karmanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

//World. Responsible for game physics.
//-------------------------------------------------------------------------------------------------

//A cell position.
class CellPos {
    var x;
    var y;
}

//World.
class World {
	//Types of cells.
    const CELL_NONE = 0;
    const CELL_WALL = 1;
    const CELL_SNAKE = 2;
    const CELL_FOOD = 3;

	//Snake movement directions.
    const DIR_UP = 0;
    const DIR_DOWN = 1;
    const DIR_LEFT = 2;
    const DIR_RIGHT = 3;

	//Projections of the movement vector to X and Y axes for all directions.
    const DX = [ 0, 0, -1, 1 ];
    const DY = [ -1, 1, 0, 0 ];
	
	//Opposite directions table.
	const OPP = [ DIR_DOWN, DIR_UP, DIR_RIGHT, DIR_LEFT ];

	//Current level number.
	var level;
	
	//2D array of world cells. Contains cell types (CELL_??? constants).
    var cells;
	
	//Array of snake element positions. Elements are organized into a ring.
    var snakePos;
	//Snake head element offset in the snakePos array.
	var snakeHeadOfs;
	//Current snake length in cells.
    var snakeLen;
	//Current snake head direction.
    var snakeDir;
	//Current snake "capacity" - the length which the snake has to grow to. 
    var snakeCapacity;
	
	//Current food position.
    var foodPos;
	//Current food weight.
    var foodWeight;
	//java.util.Random for food generation.
	var foodRnd;
	
	//true, if the snake head moved in last move() call.
	var headMoved;
	//true, if the snake tail moved in last move() call.
	var tailMoved;
	
	//true, if the snake has collided with a wall.
	var gameOver;
	//true, if the snake has eaten the last food portion in the current level.
	var levelFinished;
	
    function World(alevel, levelMap) {
		level = alevel;
		initCells(levelMap);
		initSnake(levelMap);
		
		foodRnd = new java.util.Random();
        foodPos = new CellPos();
        createFood(1);
		
		headMoved = false;
		tailMoved = false;
		gameOver = false;
		levelFinished = false;
    }
	
	//Initializes world cells according to the level map.
	function initCells(levelMap) {
        cells = new [WORLD_HEIGHT][WORLD_WIDTH];
        for (var y = 0; y < WORLD_HEIGHT; ++y) {
            for (var x = 0; x < WORLD_WIDTH; ++x) {
				cells[y][x] = levelMap.map[y][x] ? CELL_WALL : CELL_NONE;
            }
        }
	}
	
	//Initializes the snake position.
	function initSnake(levelMap) {
        snakePos = new [MAX_SNAKE_LEN + 1];
        for (var i = 0; i < snakePos.length; ++i) {
            snakePos[i] = new CellPos();
        }
       
		snakeHeadOfs = 0;
        snakeLen = 1;
        snakeCapacity = MIN_SNAKE_LEN;
		snakePos[0].y = levelMap.starty;
		snakePos[0].x = levelMap.startx;
        cells[levelMap.starty][levelMap.startx] = CELL_SNAKE;
        
		snakeDir = levelMap.startdx != 0
			? (levelMap.startdx < 0 ? DIR_LEFT : DIR_RIGHT)
			: (levelMap.startdy < 0 ? DIR_UP : DIR_DOWN);
	}
	
	//Sets snake head's direction.
	function setDirection(dir) {
		if (dir != snakeDir && dir != OPP[snakeDir]) {
			snakeDir = dir;
			return true;
		}
		return false;
	}
	
	//Single move of a snake. Moves the snake's head by one cell, and moves the tail,
	//if the snake does not have to grow.
    function move() {
		headMoved = false;
		tailMoved = false;
		
        if (snakeLen <= snakeCapacity) {
			//The snake is not too long, so its head can move.
			var cell = moveSnakeHead();
            if (cell == CELL_FOOD) {
				//Food reached.
				eatFood();
            } else if (cell != CELL_NONE) {
				//Collision with a wall.
                gameOver = true;
            }
        }
        
        if (!gameOver && snakeLen > snakeCapacity) {
			//The snake is not too short, so the tail can move.
			moveSnakeTail();
        }
    }
	
	//Moves the snake head to an adjacent cell.
	function moveSnakeHead() {
		++snakeLen;
		--snakeHeadOfs;
		if (snakeHeadOfs < 0) snakeHeadOfs = snakePos.length - 1;
		
		var oldHeadPos = getSnakePos(1);
		var sy = oldHeadPos.y + DY[snakeDir];
		var sx = oldHeadPos.x + DX[snakeDir];
		
		var headPos = getSnakePos(0);
		headPos.y = sy;
		headPos.x = sx;

		var cell = cells[sy][sx];
		if (cell != CELL_WALL) cells[sy][sx] = CELL_SNAKE;
		
		headMoved = true;
		
		return cell;
	}
	
	//Moves the snake tail.
	function moveSnakeTail() {
		var tailPos = getSnakePos(snakeLen - 1);
		cells[tailPos.y][tailPos.x] = CELL_NONE;
		--snakeLen;
		tailMoved = true;
	}
	
	//Makes the snake eat the food. Increases the snake's capacity and generates a new food,
	//if it was not the last one in the level.
	function eatFood() {
		removeFood();
		snakeCapacity = Math.min(MAX_SNAKE_LEN, snakeCapacity + (int)(FOOD_LENGTH*foodWeight));
		
		var nextWeight = foodWeight + 1;
		foodWeight = 0;
		if (nextWeight <= MAX_FOOD) {
			createFood(nextWeight);
		} else {
			levelFinished = true;
		}
	}

	//Creates a food in a random position.
    function createFood(weight) {
        for (var i = 0; i < 100; ++i) {
            var y = foodRnd.nextInt(WORLD_HEIGHT - 1);
            var x = foodRnd.nextInt(WORLD_WIDTH - 1);
            if (cells[y + 0][x + 0] == CELL_NONE
                && cells[y + 0][x + 1] == CELL_NONE
                && cells[y + 1][x + 0] == CELL_NONE
                && cells[y + 1][x + 1] == CELL_NONE)
            {
                cells[y + 0][x + 0] = CELL_FOOD;
                cells[y + 0][x + 1] = CELL_FOOD;
                cells[y + 1][x + 0] = CELL_FOOD;
                cells[y + 1][x + 1] = CELL_FOOD;
                foodWeight = weight;
                foodPos.y = y;
                foodPos.x = x;
                break;
            }
        }
    }

	//Removes the current food from the world.
    function removeFood() {
        var fy = foodPos.y;
        var fx = foodPos.x;
        removeFoodAt(fy + 0, fx + 0);
        removeFoodAt(fy + 0, fx + 1);
        removeFoodAt(fy + 1, fx + 0);
        removeFoodAt(fy + 1, fx + 1);
    }
   
    function removeFoodAt(y, x) {
        if (cells[y][x] == CELL_FOOD) cells[y][x] = CELL_NONE;
    }
	
	//Returns the position of the snake's element at the given offset relative to the
	//snake's head.
	function getSnakePos(ofs) {
		ofs += snakeHeadOfs;
		if (ofs >= snakePos.length) ofs -= snakePos.length;
		return snakePos[ofs];
	}
}
