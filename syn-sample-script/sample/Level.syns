/*
 * Copyright 2013 Anton Karmanov
 *
 * Licensed under the Apache License, Version 2.0 (the "License");
 * you may not use this file except in compliance with the License.
 * You may obtain a copy of the License at
 * 
 *     http://www.apache.org/licenses/LICENSE-2.0
 * 
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an "AS IS" BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */

// Level generator. Generates random level maps.
// -------------------------------------------------------------------------------------------------

import java.util.*;

// Random numbers generator used for level generation.
const LEVEL_RANDOM_NUMBER_GENERATOR = new Random();

// Level map returned by this module. Contains wall cells matrix, snake start position and direction.
class LevelMap {
    var wallMatrix;            // Array of arrays: wallMatrix[y][x] == true if the cell (x, y) is a wall.
    var startLocation;         // Point (.x, .y).
    var startDirection;        // Point (.x, .y: -1, 0 or 1, denoting position change on each step).
    
    function LevelMap(wallMatrix_, startLocation_, startDirection_) {
        wallMatrix = wallMatrix_;
        startLocation = startLocation_;
        startDirection = startDirection_;
    }
}

// Generates a random level map.
// Parameters:
//     mapWidth - the width of the map in blocks.
//     mapHeight - the height of the map in blocks.
//     blockWidth - the width of a block in cells.
//     blockHeight - the height of a block in cells.
// Returns:
//     a LevelMap object.
function generateLevelMap(mapWidth, mapHeight, blockWidth, blockHeight, level) {
    var mapSize = new Level_Point(mapWidth, mapHeight);
    var blockSize = new Level_Point(blockWidth, blockHeight);
    return new Level_MapGenerator(mapSize, blockSize, level).generate();
}

// Implementation details.
// -------------------------------------------------------------------------------------------------

class Level_Point {
    var x;
    var y;
    
    function Level_Point(x_, y_) {
        x = x_;
        y = y_;
    }
    
    function point(x_, y_) { return new Level_Point(x_, y_); }
    function get(axis) { return axis == 0 ? x : y; }
    function isInRectangle(p) { return x < p.x && y < p.y; }
    function addXY(x_, y_) { return point(x + x_, y + y_); }
    function mulXY(x_, y_) { return point(x * x_, y * y_); }
    function divXY(x_, y_) { return point(x / x_, y / y_); }
    function addPoint(p) { return point(x + p.x, y + p.y); }
    function subPoint(p) { return point(x - p.x, y - p.y); }
    function mulPoint(p) { return point(x * p.x, y * p.y); }
    function mulScalar(v) { return point(x * v, y * v); }
    function sum() { return x + y; }
    function reverse() { return point(y, x); }
    function length() { return Math.sqrt(x * x + y * y); }
    
    function range(endPoint, step) {
        var list = new ArrayList();
        for (var ty = y, tx = x; ty < endPoint.y && tx < endPoint.x; ty += step.y, tx += step.x) {
            list.add(point(tx, ty));
        }
        return list;
    }
    
    function range2D(endPoint) {
        var list = new ArrayList();
        for (var ty = y; ty < endPoint.y; ++ty) {
            for (var tx = x; tx < endPoint.x; ++tx) list.add(point(tx, ty));
        }
        return list;
    }
    
    function toString() { return "(" + x + ", " + y + ")"; }
}

class Level_MapGenerator {
    const WALL_RIGHT = new Level_Point(1, 0);
    const WALL_DOWN = new Level_Point(0, 1);

    var mapSize;
    var blockSize;
    var level;
    var field;

    function Level_MapGenerator(mapSize_, blockSize_, level_) {
        mapSize = mapSize_;
        blockSize = blockSize_;
        level = level_;
        field = new Level_Field(mapSize);
    }
    
    function generate() {
        generateRandomField();
        var wallMatrix = fillWallMatrix();
        var startPos = calculateStartPosition();
        var startLocation = startPos.location.mulPoint(blockSize).addPoint(blockSize.divXY(2, 2));
        return new LevelMap(wallMatrix, startLocation, startPos.direction);
    }
    
    function generateRandomField() {
        generateBorderWalls();
        generateInnerWalls();
    }
    
    function generateBorderWalls() {
        generateBorderWall(point(0, 0), WALL_RIGHT);
        generateBorderWall(point(0, field.size.y), WALL_RIGHT);
        generateBorderWall(point(0, 0), WALL_DOWN);
        generateBorderWall(point(field.size.x, 0), WALL_DOWN);
    }
    
    function generateBorderWall(startPoint, direction) {
        var endPoint = field.size.addPoint(direction.reverse());
        for (var currentPoint : startPoint.range(endPoint, direction)) field.addLink(currentPoint, direction);
    }
    
    function generateInnerWalls() {
        var mirror = chooseRandomMirror();
        
        var wallCountGoal = level - 1;
        while (calculateCurrentWallCount() < wallCountGoal) {
            if (!generateWall(mirror)) break;
        }
    }
    
    function chooseRandomMirror() {
        var mirrors = new Level_MirrorGenerator(field.size).createMirrors();
        return mirrors[LEVEL_RANDOM_NUMBER_GENERATOR.nextInt(mirrors.length)];
    }

    // If two parallel walls overlap, they are counted as a single wall.
    function calculateCurrentWallCount() {
        var count = 0;
        for (var pos : point(1, 1).range2D(field.size)) {
            if (field.isLink(pos, WALL_RIGHT) && !field.isLink(pos.addXY(-1, 0), WALL_RIGHT)) ++count;
            if (field.isLink(pos, WALL_DOWN) && !field.isLink(pos.addXY(0, -1), WALL_DOWN)) ++count;
        }
        return count;
    }
    
    // Returns true if a wall was generated, and false if there is no space for a wall.
    function generateWall(mirror) {
        var walls = generateAllPossibleWalls(mirror);
        if (walls.isEmpty()) return false;
        
        var wall = selectRandomWall(walls);
        buildWall(mirror, wall);
        return true;
    }
    
    function generateAllPossibleWalls(mirror) {
        var walls = new ArrayList();
        for (var pos : point(0, 0).range2D(mirror.mirrorSize.addXY(1, 1))) {
            generateWallsForDirection(mirror, pos, WALL_RIGHT, walls);
            generateWallsForDirection(mirror, pos, WALL_DOWN, walls);
        }
        return walls;
    }

    // Lists all possible walls that can be built at the given point and direction.
    // All the returned walls are located at the same point, but have different lengths.
    function generateWallsForDirection(mirror, pos, dir, walls) {
    
        // If the specified origin node is linked to another node, no wall can be generated.
        if (field.isLink(pos, dir)) return;
        if (field.isLink(pos.subPoint(dir), dir)) return;
        
        // Generate walls, increasing the length one by one, while possible.
        var endPos = mirror.mirrorSize.addXY(1, 1).subPoint(dir);
        for (var tpos : pos.range(endPos, dir)) {
            var len = tpos.subPoint(pos).sum() + 1;
            var wall = generateWallForPosition(mirror, pos, dir, len);
            if (wall == null || field.isLink(tpos.addPoint(dir), dir)) break;
            walls.add(wall);
        }
    }
    
    function generateWallForPosition(mirror, pos, dir, len) {
        var priority = getWallPriority(pos, dir, len);
        var wall = new Level_Wall(pos, dir, len, priority);
        return isWallLoopIncludingReflections(mirror, wall) ? null : wall;
    }

    function isWallLoopIncludingReflections(mirror, wall) {
        var componentDisjointSet = field.componentDisjointSet.clone();
        for (var curWall : mirror.allReflections(wall)) {
            if (isWallLoop(curWall, componentDisjointSet)) return true;
        }
        return false;
    }

    // Checks if a single walls forms a loop.
    function isWallLoop(wall, componentDisjointSet) {
        for (var i = 0; i < wall.length; ++i) {
            var pos = wall.location.addPoint(wall.direction.mulScalar(i));
            var node1 = field.nodeAt(pos);
            var node2 = field.nodeAt(pos.addPoint(wall.direction));
            
            var set1 = componentDisjointSet.findSet(node1.disjointSetKey);
            var set2 = componentDisjointSet.findSet(node2.disjointSetKey);
            if (set1 == set2) return true;
            
            componentDisjointSet.union(node1.disjointSetKey, node2.disjointSetKey);
        }
        
        return false;
    }

    // Calculates the priority of a wall. The priority depends on the length of the wall
    // and its location.
    function getWallPriority(pos, dir, len) {
        var centerPos = pos.addPoint(dir.mulScalar(len / 2));
        var fieldCenterPos = field.size.divXY(2, 2);
        var centerDistance = centerPos.subPoint(fieldCenterPos).length();
        var centerScore = Math.max(0, fieldCenterPos.length() - centerDistance);
        
        var maxLen = field.size.mulPoint(dir).sum() + 1;
        var lenQuotient = Math.min(len, maxLen - len);
        var lenScore = Math.pow(2, Math.min(20, lenQuotient));
        
        return (int)(centerScore + lenScore);
    }

    // The probability of selecting a wall is proportional to the wall's priority.
    function selectRandomWall(walls) {
        var prioritySum = 0;
        for (var wall : walls) prioritySum += wall.priority;

        var r = LEVEL_RANDOM_NUMBER_GENERATOR.nextInt(prioritySum);
        var s = 0;
        
        for (var wall : walls) {
            if (r >= s && r < s + wall.priority) {
                walls.remove(wall);
                return wall;
            }
            s += wall.priority;
        }
        
        return walls[walls.size() - 1];
    }

    // "Builds" the specified wall in the field, including mirror reflections.
    function buildWall(mirror, wall) {
        for (var curWall : mirror.allReflections(wall)) {
            for (var i = 0; i < wall.length; ++i) {
                var pos = curWall.location.addPoint(curWall.direction.mulScalar(i));
                field.addLink(pos, curWall.direction);
            }
        }
    }

    // Calculate a snake start position.
    function calculateStartPosition() {
        var startPosList = new ArrayList();
        findAllStartPositions(point(1, 0), startPosList);
        findAllStartPositions(point(0, 1), startPosList);
        return chooseBestStartPosition(startPosList);
    }

    function findAllStartPositions(dir, startPosList) {
        for (var basePos : point(0, 0).range(field.size, dir.reverse())) {
            var pos = basePos;
            while (pos.isInRectangle(field.size)) {
                startPosList.add(new Level_StartPosition(pos, dir));
                pos = pos.addPoint(dir.mulScalar(calculateEmptySpaceAhead(pos, dir)));
            }
        }
    }
    
    function chooseBestStartPosition(startPosList) {
        var bestPosition = startPosList.get(0);
        var bestScore = calculateStartPositionScore(bestPosition);
        
        for (var position : startPosList) {
            var score = calculateStartPositionScore(position);
            if (score > bestScore) {
                bestPosition = position;
                bestScore = score;
            }
        }
        
        return bestPosition;
    }

    function calculateStartPositionScore(position) {
        var emptySpaceScore = calculateEmptySpaceAhead(position.location, position.direction);
        
        var centerLocation = field.size.divXY(2, 2);
        var centerDistance = position.location.subPoint(centerLocation).length();
        var centerDistanceScore = Math.max(0, centerLocation.length() - centerDistance);
        
        return emptySpaceScore + centerDistanceScore;
    }
    
    function calculateEmptySpaceAhead(pos, dir) {
        var space = 0;
        for (var tpos : pos.range(field.size, dir)) {
            ++space;
            if (field.nodeAt(tpos.addPoint(dir)).isLink(dir.reverse())) break;
        }
        return space;
    }
    
    // Fills level map cells according to links defined between field nodes.
    function fillWallMatrix() {
        var gridSize = mapSize.mulPoint(blockSize).addXY(1, 1);
        
        // Fill all cells with false.
        var map = new [gridSize.y][gridSize.x];
        for (var pos : point(0, 0).range2D(gridSize)) map[pos.y][pos.x] = false;
        
        // Fill cells occupied by walls with true.
        for (var pos : point(0, 0).range2D(gridSize)) {
            fillMapLink(map, pos, WALL_RIGHT);
            fillMapLink(map, pos, WALL_DOWN);
        }
        
        return map;
    }

    // Fills a single nodes link cells.
    function fillMapLink(map, pos, dir) {
        if (field.isLink(pos, dir)) {
            var endMPos = pos.addXY(1, 1).mulPoint(blockSize).addPoint(dir);
            for (var mpos : pos.mulPoint(blockSize).range(endMPos, dir)) map[mpos.y][mpos.x] = true;
        }
    }
    
    function point(x, y) { return new Level_Point(x, y); }
}

// Disjoint-set (a simple disjoint-set forest without optimizations).
class Level_DisjointSet {
    var parentMap = new HashMap();
    
    function findSet(element) {
        for (;;) {
            var parent = parentMap.get(element);
            if (parent == null) return element;
            element = parent;
        }
    }
    
    function union(element1, element2) {
        var head1 = findSet(element1);
        var head2 = findSet(element2);
        if (head1 != head2) parentMap.put(head2, head1);
    }
    
    function clone() {
        var result = new Level_DisjointSet();
        result.parentMap.putAll(parentMap);
        return result;
    }
}

// Map node - a point located in a corner of a map block. Two adjacent nodes can be linked by a wall.
// A map contains closed regions if and only if the undirected graph formed by nodes and walls contains cycles.
// (See the comment in the top of Snake.syns for the explanation what is the difference between "map cell" and "map block".)
class Level_Node {
    var linkDown;              // true if this node (x, y) is linked with the node (x, y+1).
    var linkRight;             // true if this node (x, y) is linked with the node (x+1, y).
    var disjointSetKey;        // A string used to represent this node in a disjoint-set.
    
    function Level_Node(pos) {
        linkDown = false;
        linkRight = false;
        disjointSetKey = "" + pos.x + ":" + pos.y;
    }
    
    function isLink(dir) {
        return dir.x != 0 ? linkRight : linkDown;
    }
    
    function setLink(dir) {
        if (dir.x != 0) {
            linkRight = true;
        } else {
            linkDown = true;
        }
    }
}

// Field. Contains a 2D array of nodes.
class Level_Field {
    var size;                  // (.x, .y - width, height, even numbers, >= 2).
    var nodesTable;            // (size.y+1) by (size.x+1) nodes.

    // Disjoint-set for tracking connected components of the wall graph.
    // (Needed to avoid closed regions.)
    var componentDisjointSet = new Level_DisjointSet();
    
    function Level_Field(size_) {
        size = size_;
        
        // Create nodes table.
        nodesTable = new [size.y + 1][size.x + 1];
        for (var pos : new Level_Point(0, 0).range2D(size.addXY(1, 1))) {
            nodesTable[pos.y][pos.x] = new Level_Node(pos);
        }
    }
    
    function nodeAt(pos) {
        return nodesTable[pos.y][pos.x];
    }
    
    // Checks if there is a link between two adjacent nodes.
    function isLink(pos, dir) {
        if (pos.x < 0 || pos.y < 0 || pos.x > size.x || pos.y > size.y) return false;
        return nodeAt(pos).isLink(dir);
    }
    
    // Adds a link between two adjacent nodes.
    function addLink(pos, dir) {
        var node = nodeAt(pos);
        node.setLink(dir);
        var node2 = nodeAt(pos.addPoint(dir));
        componentDisjointSet.union(node.disjointSetKey, node2.disjointSetKey);
    }
}

// Wall. Describes one of possible walls that can be built.
class Level_Wall {
    var location;              // (.x, .y)
    var direction;             // (.x, .y: (1, 0) or (0, 1)).
    var length;                // Length.
    var priority;              // Priority: the probability of choosing a wall is proportional to its priority.
    
    function Level_Wall(location_, direction_, length_, priority_) {
        location = location_;
        direction = direction_;
        length = length_;
        priority = priority_;
    }
}

class Level_StartPosition {
    var location;
    var direction;
    
    function Level_StartPosition(location_, direction_) {
        location = location_;
        direction = direction_;
    }
}

// Reflection. Describes how to reflect one part of a field (a half or a quarter)
// into another one of the same size.
class Level_Reflection {
    var location;
    var inversion;
    
    function Level_Reflection(location_, inversion_) {
        location = location_;
        inversion = inversion_;
    }
}

// Mirror. Reflects a part of a field into the rest of the field.
class Level_Mirror {
    var fieldSize;
    var mirrorSize;
    var reflections;
    
    function Level_Mirror(fieldSize_, mirrorSize_, reflections_) {
        fieldSize = fieldSize_;
        mirrorSize = mirrorSize_;
        reflections = reflections_;
    }
    
    function allReflections(wall) {
        var walls = new ArrayList();
        walls.add(wall);
        for (var reflection : reflections) reflectWall(reflection, wall, walls);
        return walls;
    }

    function reflectWall(reflection, wall, walls) {
        var newX = reflectWallByAxis(mirrorSize, reflection, wall, 0);
        var newY = reflectWallByAxis(mirrorSize, reflection, wall, 1);
        var newLocation = new Level_Point(newX, newY);
        if (!newLocation.isInRectangle(fieldSize)) return;
        
        var newWall = new Level_Wall(newLocation, wall.direction, wall.length, wall.priority);
        
        for (var other : walls) if (wallsEqual(other, newWall)) return;
        walls.add(newWall);
    }

    function reflectWallByAxis(mirrorSize, reflection, wall, axis) {
        var reflectionPos = reflection.location.get(axis);
        var wallPos = wall.location.get(axis);
        if (reflection.inversion.get(axis) > 0) {
            return reflectionPos + wallPos;
        } else {
            return reflectionPos + mirrorSize.get(axis) - wallPos - wall.direction.get(axis) * wall.length;
        }
    }
    
    function wallsEqual(w1, w2) {
        return w1.location.x == w2.location.x && w1.location.y == w2.location.y;
    }
}

class Level_MirrorGenerator {
    var fieldSize;
    
    function Level_MirrorGenerator(fieldSize_) {
        fieldSize = fieldSize_;
    }
    
    function createMirrors() {
        return [
            createNoneMirror(),
            createVMirror(1),
            createHMirror(1),
            createVMirror(-1),
            createHMirror(-1),
            createHVMirror(1, 1, 1, 1),
            createHVMirror(1, -1, -1, 1),
            createHVMirror(-1, -1, 1, 1),
            createHVMirror(-1, -1, -1, -1),
            createHVMirror(1, -1, -1, -1)
        ];
    }

    // Mock mirror. Does not modify coordinates.
    function createNoneMirror() {
        return new Level_Mirror(fieldSize, fieldSize, []);
    }

    // Vertical mirror. Mirrors the left half of a field to its right half.
    function createVMirror(my) {
        var mirrorSize = fieldSize.divXY(2, 1);
        var reflections = [new Level_Reflection(mirrorSize.mulXY(1, 0), point(-1, my))];
        return new Level_Mirror(fieldSize, mirrorSize, reflections);
    }

    // Horizontal mirror. Mirrors the top half of a field to its bottom half.
    function createHMirror(mx) {
        var mirrorSize = fieldSize.divXY(1, 2);
        var reflections = [new Level_Reflection(mirrorSize.mulXY(0, 1), point(mx, -1))];
        return new Level_Mirror(fieldSize, mirrorSize, reflections);
    }

    // Vertical and horizontal mirror. Mirrors the top left quarter of a field to all the other quarters.
    function createHVMirror(mx1, my1, mx2, my2) {
        var mirrorSize = fieldSize.divXY(2, 2);
        
        var reflections = [
            new Level_Reflection(mirrorSize.mulXY(0, 1), point(mx1, my1)),
            new Level_Reflection(mirrorSize.mulXY(1, 0), point(mx2, my2)),
            new Level_Reflection(mirrorSize, point(mx1 * mx2, my1 * my2))
        ];
        
        return new Level_Mirror(fieldSize, mirrorSize, reflections);
    }
    
    function point(x, y) { return new Level_Point(x, y); }
}
